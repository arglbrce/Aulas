\documentclass[table]{beamer}

\usepackage{GCS-Aula_00-Style}

\input{GCS-Aula_00-Title.tex}

%----------------------------------------------------------------------------------------
%	PRESENTATION SLIDES
%----------------------------------------------------------------------------------------

%------------------------------------------------

\begin{frame}
\begin{block}{\centerline{Ferramentas de Build}}
\end{block}

\end{frame}

%------------------------------------------------

\begin{frame}

\frametitle{Índice}

\begin{itemize}
	\item Histórico
	\item Automação avançada
	\item Vantagens
	\item Tipos
	\item Script de build
\end{itemize}

\end{frame}

%------------------------------------------------

\begin{frame}

\frametitle{Histórico}

\begin{itemize}
	\item Automação de Build é o ato de criar scripts ou automatizar uma grande variedade de tarefas que os desenvolvedores de software fazem no seu dia-a-dia, tais como:
	\begin{itemize}
		\item Compilação de código fonte em código binário
		\item Empacotamento do código binário
		\item Executar Testes
		\item Implantação de sistemas em produção
		\item Criação de documentação e/ou notas de lançamento
	\end{itemize}
\end{itemize}

\end{frame}

%------------------------------------------------

\begin{frame}

\frametitle{Histórico}

\begin{itemize}
	\item Historicamente, os desenvolvedores chamam os compiladores e linkers de dentro de um script de construção ao invés de chamar o compilador pela linha de comando
	\item É simples usar a linha de comando para compilar um único arquivo fonte e depois chamar um linker para criar o objeto final, no entanto, ao tentar compilar e ligar muitos arquivos de código fonte, em uma ordem específica, usar o processo de linha de comando não parece ser uma solução razoável
\end{itemize}

\end{frame}

%------------------------------------------------

\begin{frame}

\frametitle{Histórico}

\begin{itemize}
	\item A linguagem de script chamada \texttt{make} ofereceu uma alternativa melhor
	\begin{itemize}
		\item Permite construir um script com os comandos necessários para compilar um aplicativo
		\item O GNU make também ofereceu recursos adicionais, tais como \texttt{makedepend}, bem como a builds incrementais
	\end{itemize}
	\item Este foi o início da automação de builds, onde seu foco principal foi automatizar as chamadas para os compiladores e linkers.
\end{itemize}

\end{frame}

%------------------------------------------------

\begin{frame}

\frametitle{Histórico}

\begin{itemize}
	\item A medida que o processo de build tornou-se mais complexo, os desenvolvedores começaram a adicionar ações pré-compilação e pós-compilação, como o \texttt{check-out} do controle de versão para uma cópia de trabalho.
\end{itemize}

\end{frame}

%------------------------------------------------

\begin{frame}

\frametitle{Automação Avançada}

\begin{itemize}
	\item O termo \textit{builds distribuídas} significa que as chamadas reais para o compilador e linkers podem ser executadas em vários servidores para melhorar a velocidade da compilação
	\item Este termo é muitas vezes confundido com \textit{processamento distribuído}
	\begin{itemize}
		\item Processamento distribuído significa que cada etapa de um processo ou fluxo de trabalho pode ser enviado para uma máquina diferente para a execução.
		\item Por exemplo, um dos passos da build pode exigir a execução de scripts de testes em várias máquinas
	\end{itemize}
\end{itemize}

\end{frame}

%------------------------------------------------

\begin{frame}

\frametitle{Automação Avançada}

\begin{itemize}
	\item O processo de build distribuída deve ter inteligência suficiente para compreender as dependências de código-fonte, a fim de enviar as diferentes etapas de compilação para máquinas diferentes
	\begin{itemize}
		\item Deve ser capaz de gerenciar essas dependências, a fim de realizar compilações distribuídas
		\begin{itemize}
			\item Executar a compilação de modo paralelo
			\item Compilador pode ser chamado em modo \textit{multi-threads} usando uma máquina que possui mais de um núcleo
		\end{itemize}
	\end{itemize}
\end{itemize}

\end{frame}

%------------------------------------------------

\begin{frame}

\frametitle{Automação Avançada}

\begin{itemize}
	\item Nem todas as ferramentas de automação podem executar build distribuída
	\begin{itemize}
		\item A maioria apenas fornece suporte ao processamento distribuído
		\item A maioria das soluções dão suporte apenas a C/C++.
	\end{itemize}
	\item Um exemplo de solução de build distribuída é o IncrediBuild Xoreax para a plataforma Microsoft Visual Studio
\end{itemize}

\end{frame}

%------------------------------------------------

\begin{frame}

\frametitle{Automação Avançada}

\begin{itemize}
	\item IncrediBuild Xoreax:
	\begin{figure}
		\includegraphics[scale=0.6]{./images/xoreax-01.png}
	\end{figure}
\end{itemize}

\end{frame}

%------------------------------------------------

\begin{frame}

\frametitle{Vantagens}

\begin{itemize}
	\item Melhora a qualidade do produto
	\begin{itemize}
		\item Acelerar o processo de compilação e link
		\item Eliminar tarefas redundantes
		\item Minimiza as \emph{bad build}
		\item Elimina a dependência de pessoa-chave
		\item Possui histórico de versões e \emph{releases} para investigar problemas
		\item Poupa tempo e dinheiro (por causa das razões listadas acima)
	\end{itemize}
\end{itemize}

\end{frame}

%------------------------------------------------

\begin{frame}

\frametitle{Vantagens}

\begin{itemize}
	\item \textbf{On-Demand:} um usuário executa um script na linha de comando
	\item \textbf{Automação agendadas:} um servidor de integração contínua executa uma \texttt{nightly build}
	\item \textbf{Automação por evento:} um servidor de integração contínua executando uma build a cada commit de um sistema de controle de versão
\end{itemize}

\end{frame}

%------------------------------------------------

\begin{frame}

\frametitle{Script de Build}

\begin{itemize}
	\item Uma forma específica de automação de build é a criação de scripts de build (Makefiles). Isto é conseguido através de ferramentas como:
	\begin{itemize}
		\item GNU Automake
		\item Cmake
		\item Imake
		\item Qmake
		\item Apache Ant
		\item Apache Maven
		\item OpenMake Meister
	\end{itemize}
\end{itemize}

\end{frame}

%------------------------------------------------

\begin{frame}

\frametitle{Script de Build}

\begin{itemize}
	\item Requisitos \textbf{básicos} de um sistema de build
	\begin{itemize}
		\item Processo de compilação incremental.
		\item Build frequente durante a noite para detectar os problemas mais cedo.
		\item Suporte à gerenciamento de dependência de código fonte.
		\item Relatar que arquivos fonte deram origem à um determinado executável.
		\item Construção rápida.
		\item Relatórios sobre a construção, compilação e link.
	\end{itemize}
\end{itemize}

\end{frame}

%------------------------------------------------

\begin{frame}

\frametitle{Script de Build}

\begin{itemize}
	\item Requisitos \textbf{opcionais} de um sistema de build
	\begin{itemize}
		\item Gerar notas de lançamento e outros documentos, como páginas de ajuda.
		\item Construir relatórios de status.
		\item Relatórios de aprovação ou reprovação de teste.
		\item Resumo dos recursos adicionados / modificados / excluídos a cada nova compilação.
	\end{itemize}
\end{itemize}

\end{frame}

%----------------------------------------------------------------------------------------

\end{document}